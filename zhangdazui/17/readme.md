# 17 | 时间和空间复杂度（下）：如何使用六个法则进行复杂度分析？

## 广度优先搜索

1. 判断边界条件 O(1)；
2. 生成空的队列 O(1)；
3. 搜索的起始结点放入队列 O(1);
4. while 和 for 的两个循环嵌套 O(m*l);
5. 将前面4步相加，因此时间和空间复杂度都是 O(m^l)。

## 双广度优先搜索 

双向搜索所要走的边数。如果单向需要走 l 条边，那么双向是 l/2。因此时间和空间复杂度都会变为 O(2*m^(l/2)，简写为 O(m^(l/2))。

## 全文搜索

两种搜索方式

1. 把全文作为一个很长的字符串，把用户输入的关键词作为一个子串，那这个搜索问题就变成了子串匹配的问题。假设字符串平均长度为 n 个字符，关键词平均长度为 m 个字符，使用最简单的暴力法，就是把代表全文的字符串的每个字符，和关键词字符串的每个字符两两相比，那么时间复杂度就是 O(n*m)。
2. 对全文进行分词，把全文切分成一个个有意义的词，那么这个搜索问题就变成了把输入关键词和这些切分后的词进行匹配的问题。时间复杂度是 O(logm)

第二种就是典型的时间换空间的方法。

## 思考题

Q: 在你日常的工作中，有没有经历过性能分析相关的项目？如果有，你都使用了哪些方法来分析问题的症结？
A: 前端的这快对数据的处理很少。如果写数据的处理方法还是会使用事件复制度分析，还有输出执行该函数的前后时间差。有时也会使用 jsperf.com 网站进行时间对比。