## 09 | 动态规划（上）：如何实现基于编辑距离的查询推荐？

有时候，我们并不用处理所有可能的情况，只要找到满足条件的最优解就行了。在这种情况下，我们需要在各种可能的局部解中，找出那些可能达到最优的局部解，而放弃其他的局部解。这个寻找最优解的过程其实就是动态规划。

### 核心思想

面对大问题，将大问题拆分为若干个小问题，先从小的条件开始寻找相关规律，然后从开始进行模拟运算，之后再写算法。

> 动态规划需要通过子问题的最优解，推导出最终问题的最优解，因此这种方法特别注重子问题之间的转移关系。我们通常把这些子问题之间的转移称为状态转移，并把用于刻画这些状态转移的表达式称为状态转移方程。很显然，找到合适的状态转移方程，是动态规划的关键。

不需要处理所有的情况，只需要找到满足条件的最优解。

### 编辑距离

比较关键词相关性的算法，由一个字符串转成另一个字符串所需的最少编辑操作次数，我们就叫作编辑距离。这个概念是俄罗斯科学家莱文斯坦提出来的，所以我们也把编辑距离称作莱文斯坦距离（Levenshtein distance）。

求解过程：

1. 通过排列实现？A 所有的可能排列数量级在 m^n 的级别。所以不能用排列。
2. 但其实我们只关心最优解，就是最短距离。所以拆分子问题后，我们只需要保留最优解，然后继续下一步即可。

编辑三种基础操作：替换一个字符；插入一个字符；删除一个字符。

先从 A、B 都是空字符串开始，显然是 0，此时 A 增加 a1，B 为空，那么编辑距离增加 1，反之亦然。如果此时 A、B 都有一个字符，那么就需要区分情况。

A 为 a1，B 增加一个 b1，此时编辑距离增加 1，这是一个插入操作。

A 和 B 同时增加一个值，如果不同，此时编辑距离增加 1，这是替换操作。如果相同，则保持不变。

因此变成两个步骤：

1. 每次读取 A 和 B 的一个字符，进行对比判断，同时跟上一次的结果进行最小数计算
2. 计算的过程就是状态转移方程，判断 a1 和 b1 的编辑距离是否相等，然后跟上次计算后的距离比较

以 mouse vs mouuse 为例：

```
'' '' m o u s e
'' 0  1 2 3 4 5
m  1  0 1 2 3 4
o  2  1 0 1 2 3
u  3  2 1 0 1 2
u  4  3 2 1 1 2
s  5  4 3 2 1 2
e  6  5 4 3 2 1
```

m vs ''
m - m = 1 步操作

m vs m
m = m = 0 步操作

m vs mo
m + o = 1
mo - o = 2 + 1 = 3
所以至少要 1 步操作

m vs mou
= mo vs mou + 上一次 mo 最少操作
mo + u = mou = 1 + 1 = 2
mou - u = mo = 3 + 1 = 4
最小为 2 步

所以可以看到，两个值相交的地方，是当前最少的编辑次数，上面和左边分别可能是插入或者删除的操作，因此需要 +1，同时替换是可以进行两两比对可以为 0。

所以状态转移方程就是 min( 上 + 1, 左 + 1, 相同 ？左上 ：左上 + 1)。

其实也有倒推的，先比较最后一个字符，然后再往前推，比如： <https://www.cnblogs.com/yulinfeng/p/7096882.html>

### 思考题

Q: 你觉得根据编辑距离来衡量字符串之间的相似程度有什么局限性？你有什么优化方案吗？

1. 字符串比较长之后，计算量加大效率很低。方案：切割单词，提取关键名词，在进行对比和分别计算，然后累加？
2. 只是冷冰冰的算法对比，没有语义性的加分。比如输入 worder，本来想要输入 worker 但 wonder 等等其他单词有同样的编辑距离，就没法推荐了。方案：需要分析上下文和相关性，结合搜索频次增加单词权重，比如编辑距离都为 1，想要输入 worker 的可能性比 wonder 的大。这个就有点麻烦了。
