# 15 | 从树到图：如何让计算机学会看地图？

地图导航 App 的算法。可以将地图转换为图，然后每个边根据交通因素等进行加权，然后规划路线的时候就根据用户选择的：最短路径、最短时间等条件进行最优通路查询。

首先需要遍历找到可以连通的路线，参照上一节的双向广度优先遍历找到可以连通起点和终点的边。之后遍历所有可能的路线，累加权重（比如时间、距离）来得出最优解。但是有两个问题：

1. 遍历所有的路，一个结点可能在不同路线中被多次访问。
2. x-》s 假设有多条通路，一开始算了一条 x-》s-》h 的路线权重，如果 x-》s 有了更新的最小权重时，需要同时更新 s-》h 的权重，这样才能代表 x-》h 的最小路线权重。

## 优化版本算法：Dijkstra 算法

主要目标：减少访问结点的次数，减少计算量，提升算法效率。

有点动态规划的思路，当 A 可以连通 B、C、D 结点的时候，可以找出最小权重的结点（假设 C），之后这个点我就不需要再次处理了，因为它已经被确定为是最优解了。而且在这个场景下，每条边的权重都是正值，也就是说如果 A-C 小于 A-B，那么不存在一个正值让 A-B-C 小于 A-C。

之后再把 C 点连通的点继续拉进来，计算 A 到后面结点的最短距离，最终可以计算出 A 到每个结点的最短距离，这样就可以得到最优解。

### 算法步骤

基本概念标记：

- 起点：S
- 任意边权重：W，W[m, n] 表示 m 到 n 边的权重
- 最小权重：M，M[m] 表示起点 S 到结点 m 的最小权重
- 完成的集合：F，用来存储计算过最小结点的结点，之后跳过

#### 初始化：

1. 设置 M[S] = 0
2. F.push(S)
3. 获取 S 能到达结点的边，获取最小边（W[S, m] 们比较)，然后更新 M[m] = W[S, m]

#### 重复步骤：

1. 从 M[x] 里面获取一个最小值，这个就是当前 S 到这个结点最小值，把这个结点加入 F，不再处理。
2. 查看这个 x 结点是否可以通往其他结点？如果可以，把其他结点的权重是否比当前这个 M[x] 更小，如果是，就把这个结点的 M[m] 更新成这个结点。公式：if M[x] + W[x, y] < M[y]; M[y] = M[x] + W[x, y]。这样 x 称为 y 的前驱结点，然后让 S -》y 最小。然后使用一个其他的数据结构，记录该条路径。

直到所有结点全部处理完成，这样 S 到所有结点都有最小权重的值，并且保存了路径。

### 数学归纳法证明

命题：对于任意一个点，Dijkstra 算法都可以找到它和起始点 s 之间拥有最小权重的通路。

首先，当 n=1 的时候，也就是只有起始点 s 和另一个终止点的时候，Dijkstra 算法的初始化阶段的第 3 步，保证了命题的成立。

然后，我们假设 n=k-1 的时候命题成立，同时需要证明 n=k 的时候命题也成立。命题在 n=k-1 时成立，表明从点 s 到 k-1 个终点的任何一个时，Dijkstra 算法都能找到拥有最小权重的通路。那么再增加一个结点 x，Dijkstra 算法同样可以为包含 x 的 k 个终点找到最小权重通路。

TODO 自己证明

## 思考题

1. 如果边的权重是负数，我们还能用今天讲的 Dijkstra 算法吗？

不能，我们将一个结点放在 F 里面，不再进行后续的处理的前提，是边是一个正值，然后会递增，如果可能是负数，那么无法取出结点，因为不确定未来结点累加值更小。

2. 如果地图中存在多条最优路径，也就是说多条路径的权重和都是相等的，那么我刚刚介绍的 Dijkstra 算法应该如何修改呢？

取出所有最小值都放入 F 中，然后再从这些最小值继续出发。从以前一个变成一个集合。
