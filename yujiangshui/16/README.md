# 16 | 时间和空间复杂度（上）：优化性能是否只是“纸上谈兵”？

影响性能的因素：

1. 算法理论上的计算复杂度
2. 开发实现的方案
3. 硬件设备的规格

## 基本概念

算法复杂度通常只是一个估计值，衡量程序运行时所需要的资源，比较算法性能的好坏。分析时考虑三种情况：最差情况、最好情况和平均情况。通常最关注两个部分：时间和空间。

算法复杂度并不完全准确，通常会将结果进行优化，减少一些因子，比如 Q(1 + 2n) 会优化成 Q(n)。

> 为什么可以这么去简化呢，因为大 O 符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。 如果 n 无限大的时候，T(n) = time(1+2n)中的常量 1 就没有意义了，倍数 2 也意义不大。因此直接简化为 T(n) = O(n) 就可以了。(<https://blog.csdn.net/jsjwk/article/details/84315770>)

常见的时间复杂度量级有：

- 常数阶 O(1)
- 对数阶 O(logN)
- 线性阶 O(n)
- 线性对数阶 O(nlogN)
- 平方阶 O(n²)
- 立方阶 O(n³)
- K 次方阶 O(n^k)
- 指数阶(2^n)

## 6 个通用法则

### 四则运算法则

- 代码平行增加：加法
- 代码循环嵌套或者函数嵌套：乘法

### 主次分明法则

通常可以只看最高数量级的数字，忽略掉常量、系数和较低数量级的复杂度。

举个例子，我们首先通过随机函数生成一个长度为 n 的数组，然后生成这个数组的全排列。通过循环，生成 n 个随机数的时间复杂度为 O(n)，而全排列的时间复杂度为 O(n!)，如果使用四则运算法则，总的时间复杂为 O(n)+O(n!)。不过，由于 n! 的数量级远远大于 n，所以我们可以把总时间复杂度简化为 O(n!)。

注意，这个法则对于乘法或除法并不适用，因为乘法或除法会改变参与运算的复杂度的数量级。

### 齐头并进法则

要同时考虑所有因素，并在复杂度公式中体现出来。

### 排列组合法则

用排列组合的方式算出运行次数，然后进行复杂度计算。

### 一图千言法则

通过画图特别是树状图来思考和解决复杂度。

### 时空互换法则

在给定计算量下，通常时间复杂度和空间复杂度呈现数学中的反比关系。或许可以通过增加空间复杂度来达到降低时间复杂度的目的，或者反之。比如缓存系统。

## 思考题

Q：双向广度优先搜索的时间和空间复杂度。
A：先拆开两步，单向广度优先算法的时间和空间复杂度，假设每个结点有 N 个子结点，两人之间是 Y 度好友，那么单向广度的算法就是 O(N^Y)，双向的话就是 O(N^(Y/2)) \* 2。
