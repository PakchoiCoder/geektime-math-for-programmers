# 加餐

## 二进制

### 二进制的符号位

符号位是有富豪二进制数的最高位，用它来表示负数。因为在 CPU 运算器，只实现了加法器，没有实现减法器，因此通过加上一个负数来达到这个目的。

所以为了让计算机区分正负数，就把二进制数分为有符号数（signed）和无符号数（unsigned）。如果是有符号数，最高位为 0 表示正数，为 1 表示负数。如果是无符号数，最高位也是内容的一部分。

### 溢出

在 Java 中，int 类型是 32 位，它的最大值也就是上限是 2^31-1 最高位是符号位，所以是 31 次方，最小值就是 -2^31。

一旦数字超出了这个限制就会发生溢出，超出上限是上溢出（overflow），超出下限是下溢出（underflow）。n 位数字的最大正值，符号位是 0，但在增大一个，就变成符号位为 1 后面完全为零了，这样就瞬间变成了最小值。之后再次累加反转，其实这是余数和取模的概念。

计算机数据的溢出，就相当于取模。用于取模的除数的数据类型的上限减去下限的值，再加上 1。

### 原码、反码及补码

原码就是我们看到的二进制的原始表示。对于有符号的二进制来说，原码的最高位是符号位，而其余的位用来表示该数字绝对值的二进制。所以 +2 的原码是 000…010，-2 的的原码是 100.…010。

目前以 3+(-2) 为例，我们把 3 的二进制原码 000…011 和 -2 的二进制原码 100…010 相加，会得到 100…0101。翻译成十进制是 -5 这显然是不对的。

那么如何进行这类的运算呢？解决这个问题需要依赖溢出机制，我们对剑法进行变化，让 i-j + 取模的除数，正好形成溢出切换掉符号位，所以 `i-j=(i-j)+(2^n-1+1)=i+(2^n-1-j+1)`。

2^n-1-j 所对应的编码称为负数 -j 的反码。所以，-2 的反码就是 1111…1101。

有了反码的定义，那么就可以得出 i-j=i+(2^n-1-j+1)=i 的原码 +(-j 的反码)+1。如果我们把 -j 的反码加上 1 定义为 -j 的补码，就可以得到 i-j=i 的原码 +(-j 的补码)。

所以加负数的时候，需要用补码进行运算，正好利用溢出处理符号位得到正确的结果。
