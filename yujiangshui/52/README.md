# 加餐

## 二进制

### 二进制的符号位

符号位是有富豪二进制数的最高位，用它来表示负数。因为在 CPU 运算器，只实现了加法器，没有实现减法器，因此通过加上一个负数来达到这个目的。

所以为了让计算机区分正负数，就把二进制数分为有符号数（signed）和无符号数（unsigned）。如果是有符号数，最高位为 0 表示正数，为 1 表示负数。如果是无符号数，最高位也是内容的一部分。

### 溢出

在 Java 中，int 类型是 32 位，它的最大值也就是上限是 2^31-1 最高位是符号位，所以是 31 次方，最小值就是 -2^31。

一旦数字超出了这个限制就会发生溢出，超出上限是上溢出（overflow），超出下限是下溢出（underflow）。n 位数字的最大正值，符号位是 0，但在增大一个，就变成符号位为 1 后面完全为零了，这样就瞬间变成了最小值。之后再次累加反转，其实这是余数和取模的概念。

计算机数据的溢出，就相当于取模。用于取模的除数的数据类型的上限减去下限的值，再加上 1。

### 原码、反码及补码

原码就是我们看到的二进制的原始表示。对于有符号的二进制来说，原码的最高位是符号位，而其余的位用来表示该数字绝对值的二进制。所以 +2 的原码是 000…010，-2 的的原码是 100.…010。

目前以 3+(-2) 为例，我们把 3 的二进制原码 000…011 和 -2 的二进制原码 100…010 相加，会得到 100…0101。翻译成十进制是 -5 这显然是不对的。

那么如何进行这类的运算呢？解决这个问题需要依赖溢出机制，我们对剑法进行变化，让 i-j + 取模的除数，正好形成溢出切换掉符号位，所以 `i-j=(i-j)+(2^n-1+1)=i+(2^n-1-j+1)`。

2^n-1-j 所对应的编码称为负数 -j 的反码。所以，-2 的反码就是 1111…1101。

有了反码的定义，那么就可以得出 i-j=i+(2^n-1-j+1)=i 的原码 +(-j 的反码)+1。如果我们把 -j 的反码加上 1 定义为 -j 的补码，就可以得到 i-j=i 的原码 +(-j 的补码)。

所以加负数的时候，需要用补码进行运算，正好利用溢出处理符号位得到正确的结果。

#### 评论区补充

原码：除符号位外的其他位，保存该二进制数的绝对值。
例如 1：0001 -1：1001

反码：正数的反码等于原码；
负数的反码就是其原码除符号位外，按位取反。
例如 1：0001 -1: 1110

补码：正数的补码等于其原码
负数的的补码等于反码加一
例如 1：1001 -1：1111

## 位操作应用

### 验证奇偶数

偶数的二进制最后一位总是 0，而奇数的二进制最后一位总是 1，因此对于给定的某个数字，我们可以把它的二进制和数字 1 的二进制进行按位“与”的操作，取得这个数字的二进制最后一位，然后再进行判断。

and(&) 与运算是相同位置的两个数字都为 1 则为 1，否则为 0。所以当 and 1 时相当于跟 true 做 and 运算，两个都为 true 结果为 true，这就说明前面数字一定是 1。

or(|) 或运算类似，就是无条件赋值，强制末位变成 1。

### 交换数字

一般交换需要中间变量，但是可以用异或的特性避免这个中间变量。

异或是两个值如果不相同则为 1 or true，在相同的时候，结果为 0。

异或的特性：

- 任意变量 x 与自身异或结果为 0，即：x^x = 0
- 任意变量 x 与 0 进行异或运算，结果不变，即：x^0 = x
- 异或运算的结合性：a^b^c = (a^b)^c = a^(b^c)
- 异或运算的交换性：a^b = b^a

所以公式：

```
x = (x ^ y);
y = x ^ y;
x = x ^ y;
```

推导：

第一步先计算出 x，然后代入第二步就可以得到：`y = (x ^ y) ^ y = x ^ (y ^ y) = x ^ 0 = x`，发现其实结果就是将 x 换给了 y。

类似于：

```
x = x + y;
y = x - y; // 此时用上面 x 的减去 y
x = x - y;
```

### 集合操作

假设有 {1, 3, 8} 和 {4, 8} 两个集合，可以先转成 8 位的二进制，就是取最大值作为位数，每一位如果有值则标记为 1。所以 1，3，8 就是 10000101，4，8 就是 10001000。这样两个二进制数按位与得出来的就是交集，然后再按位翻译过来就是 8。按位或就是并集。

Elasticsearch 的 BitSet 也是利用了类似的实现，它是一个巨大的位数组，每一位都对应了某篇文档是否和给定的关键词匹配，匹配就是 1 否则就是 0。每个关键词也有一个 BitSet 自己占据一个固定位置，用来表示哪些文档跟这个关键词匹配。

之后要同时查看命中多个关键词的文档有哪些，可以先把多个关键词做并集，然后在跟所有文档做交集即可。

## 二分查找时的两个细节

### 防止计算中间值时溢出

原来的公式：`int middle = (left + right) / 2;` 替换成 `int middle = left + (right - left) / 2;` 就可以防止溢出。

假设 left 和 right 都是最大值 - 1，那么相加绝对会溢出。但是相减一定不会溢出，此时再加上 left 的值，也不会超出原来 right 的值，所以不会产生溢出。

### 误差百分比和绝对误差

```
double delta = Math.abs((square / n) - 1);
```

这里使用了误差的百分比，就是误差值占输入值 n 的比例。假设 n 是一个很小的正整数，那么误差可能要精确到 0.000001。但如果是一个很大的数，也许精确到 0.1 就可以了，使用误差百分比可以避免由于不同的 n 导致迭代次数有过大差异。

## 迭代法、数学归纳法和递归

迭代和递归都是通过不断反复的步骤，计算数值或进行操作的方法。迭代一般适合正向思维，而递归一般适合逆向思维。

对于某些重复性的计算，数学归纳法可以从理论上证明某个结论是否成立。如果成立，就可以大大节约迭代法中数值计算部分的时间。不过在使用之前，需要通过一些数学知识，假设命题，并证明该命题成立。

利用函数的嵌套，递归可以存储很多中间变量，因此可以很轻松的跟踪不同的分之，使用循环则很难自己创建和保存临时变量。但是因为这样，递归比较消耗内存。

递归本身也体现了分治的思想，这个思想还可以延伸到分布式架构中，例如 MapReduce 框架。

几个原则：

- 如果一个问题可以被迭代法解决，而且是有关数值计算的，那么就看看是否可以假设命题，并优先用数学归纳法解决。
- 如果需要借助计算机，优先考虑循环，在考虑嵌套调用和递归。
- 如果数据量过大，考虑分治思想的分布式系统来处理。
