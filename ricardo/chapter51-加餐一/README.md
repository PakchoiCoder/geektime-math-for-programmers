# 我们为什么需要反码和补码？
- 很赞的
### 自己的理解
####  源码
- 对于位数确定的二进制数字来说，源码有正负之分，正值最高位为0，负值最高位为1，当然某些语言中是没有符号位的
- 32位的2进制对应的十进制是2^n-1  - 1,因为最高位为0， 0111****1111111
- 32位的2进制对应的十进制最小值是-2^n-1,因为最高位为1  1000******00000

### 为什么存在反码
- 负数的源码是不可以和正数的源码一起计算的
- 根据计算机的溢出规则和符号位 获得反码的概念，负数的反码 + 1，即为负数的补码
- 由于正数的计算不需要这么麻烦，所以证书的 原码、反码、补玛都一样
- 计算机存储的就是补码
为何用补码，可以通过如下四位数模拟补码从0开始一直加1的情况


      0000 = 0
      0001 = 1
      0010 = 2
      0011 = 3
      0100 = 4
      0101 = 5
      0110 = 6
      0111 = 7
      1000 = -8
      1001 = -7
      1010 = -6
      1011 = -5
      1100 = -4
      1101 = -3
      1110 = -2
      1111 = -1
      0000 = 0 （再加1又从0开始了，上面表示的不同数值的个数是2^4=16,所以模是16）


- 通过途中比较容易看出来，源码和反码、补码的关系，还需要在想下如何通过图解来理解
- 如何让加法达到减法一样的效果，那就是加一个能够溢出上限的数字（上限可以理解为硬件决定的最大值，比如32位就是2^32-1），溢出上限之后的部分又从下限位置（就是0）开始累加（除模取余）。假设做减法的数a，能达到相同效果做加法的数为b，前辈们发现上限减下限加一（模的大小）和a加b的和大小竟然一样。。。（(๑>؂<๑）），好吧，那就把-a映射到b吧，就可以永远做加法了，把这个映射操作叫做求补码吧。
就好比是一个只能顺时针走的（加法）时钟，如果要时针走移到过去时间的位置，一个是逆时针移（减法）（不行，只能顺时针走），另一个就是顺时针移，其中逆时针移动量的‘补码’就是顺时针移动量（数字取反加一其实和用模减去这个数字是一样的结果）。
所谓的溢出上限可以类比为顺时针走过了0点位置。
要理解清楚：原码/代码层的数字表示；补码/硬件层面的数字表示，可以达到只做加法，结果准确的效果。

##### 反码 补码 的推到还是不怎么理解，与溢出有关，但是没看懂图