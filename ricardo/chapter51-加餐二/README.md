### 位操作
- 按位操作符（Bitwise operators） 将其操作数（operands）当作32位的比特序列（由0和1组成），而不是十进制、十六进制或八进制数值。
- 按位与 a & b
- 按位或 a | b
- 按位异或 a ^ b 对于每一个比特位，当两个操作数相应的比特位有且只有一个1时，结果为1，否则为0。
- 按位非 ～ a
- 左移 a << b 将 a 的二进制形式向左移 b (< 32) 比特位，右边用0填充。
- 有符号右移 a >> b  将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位。
- 无符号右移 a >>> b 将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，并使用 0 在左侧填充。
####  验证奇偶数
- 使用位运算和模运算的效率。位运算的效率会更高
- 很明显可以发现 奇数二进制最后一位为1 偶数为0
- 判断奇偶的时候，可以将任何一个数字和1按位与    a&b,这个时候之比较最后一位是否相同来判断奇偶
#### 交换两个数字
-  按位异或 a ^ b 对于每一个比特位，当两个操作数相应的比特位有且只有一个1时，结果为1，否则为0。
- y = (x ^ y) ^ y = x ^ (y ^ y) = x ^ 0 = x


    y = (x ^ y) ^ y = x ^ (y ^ y) = x ^ 0 = x

    x = (x ^ y) ^ x = (x ^ x) ^ y = 0 ^ y = y   

#### 集合操作
- 假设我们有两个集合{1, 3, 8}和{4, 8}。我们先把这两个集合转为两个 8 位的二进制数，从右往左以 1 到 8 依次来编号。那么第一个集合就可以转换为 10000101，第二个集合可以转换为 10001000。那么这两个二进制数的按位与就是 10000000，只有第 8 位是 1，代表了两个集合的交为{8}。而这两个二进制数的按位或就是 10001101，第 8 位、第 4 位、第 3 位和第 1 位是 1，代表了两个集合的并为{1, 3, 4, 8}。

### 二分查找时的两个细节
- 在数字变量加减的时候需要考虑 数字是否会发生溢出

### 关于迭代法、数学归纳法和递归
- 如果一个问题可以被迭代法解决，而且是有关数值计算的，那你就看看是否可以假设命题，并优先考虑使用数学归纳法来证明；
- 如果需要借助计算机，那么优先考虑是否可以使用循环来实现。如果问题本身过于复杂，再考虑函数的嵌套调用，是否可以通过递归将问题逐级简化；
- 如果数据量过大，可以考虑采用分治思想的分布式系统来处理。
### 在 1 到 n 的数字中，有且只有唯一的一个数字 m 重复出现了，其它的数字都只出现一次。请把这个数字找出来。提示：可以充分利用异或的两个特性。
- 相同的两个数异或为0
-   任何一个数和 0 异或之后，还是这个数不变
-  (1^2...^m...^n)^(1^2...^m...^n)^m = 0^m = m