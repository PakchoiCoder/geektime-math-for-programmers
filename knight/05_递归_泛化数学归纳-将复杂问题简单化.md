## 递归 (上):泛化数学归纳，如何将复杂问题简单化

## 示例问题
有1、2、5、10元面额的金钱，求解任意张能总和金额为10的情况有几种。

## 如何把复杂的问题简单化

即如何将数学归纳法的思想泛化成更一般的情况？那么首先来看数学归纳法需要考虑的两种情况:

1. 初始状态，也就是 n = 1 的时候，命题是否成立
2. 如果 n = k-1 的时候命题成立。那么只要证明 n = k的时候，命题也成立。其中k为大于1的自然数。

将上述两点顺序更换一下，再抽象化一下，我们可以得出这样的递推关系

1. 假设 n = k-1 的时候，问题已经解决了（或者已经找到解了）。那么只要求 n=k的时候，问题如何解决
2. 初始状态，就是 n = 1 的时候，问题如何解决。

总结这种思想，即：将复杂的问题，每次都解决一点点，并将剩下的任务转化成更简单的问题等待下次求解，如此反复，直到最简单的形式。

## 求解示例问题
```

import java.util.ArrayList;

public class Lesson5_1 {
  
  public static long[] rewards = {1, 2, 5, 10};  // 四种面额的纸币
  
  /**
    * @Description:  使用函数的递归（嵌套）调用，找出所有可能的奖赏组合
    * @param totalReward-奖赏总金额，result-保存当前的解
    * @return void
    */
  
    public static void get(long totalReward, ArrayList<Long> result) {
      
      // 当totalReward = 0时，证明它是满足条件的解，结束嵌套调用，输出解
      if (totalReward == 0) {
        System.out.println(result);
       return;
     }
      // 当totalReward < 0时，证明它不是满足条件的解，不输出
      else if (totalReward < 0) {
        return;
      } else {
        for (int i = 0; i < rewards.length; i++) {
          ArrayList<Long> newResult = (ArrayList<Long>)(result.clone());  // 由于有4种情况，需要clone当前的解并传入被调用的函数
          newResult.add(rewards[i]);            // 记录当前的选择，解决一点问题
          get(totalReward - rewards[i], newResult);    // 剩下的问题，留给嵌套调用去解决
        }
      }
      
    }

}
```

## 小结

递归和循环其实都是迭代法的实现，而且在某些场合下，它们的实现是可以相互转换的。
但是，对于某些应用场景，递归确很难被循环取代。 主要有两点原因:

第一，递归的核心思想和数学归纳法类似，并更具有广泛性。这两者的类似之处体现在：**将当前
的问题化解为两部分：一个当前所采取的步骤，和另一个更简单的问题**

**1.一个当前所采取的步骤**。这种步骤可能是进行一次运算,或者是不同类型操作的结合等等。

**2.另一个更简单的问题**。经过上述步骤之后，问题就会变得更加简单一点。注意，这里的”简单一点“，
指的是运算的结果离目标值更近，或者是完成了更多的选择，即规模变小了。而”更简单的问题“，又可以通过嵌套调用，进一步
简化和求解，直至达到结束约束条件。


我们只需要保证递归编程能够体现这种将复杂问题逐步简化的思想，那么它就能帮助我们解决很多类似的问题。

第二，递归会使用计算机的函数嵌套调用。而函数的调用本身，就可以保存很多中间状态和变量值，因此极大的方便了编程的处理。

正是如此，递归在计算机编程领域中有着广泛的应用，而不仅仅局限在求和等运算操作上。


