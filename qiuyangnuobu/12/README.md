## 树的深度优先搜索（下）：如何才能高效率地查字典？

### 如何使用数据结构表达树

计算机中最基本的数据结构是数组和链表
- 数组：数组适合快速地随机访问。不过，数组并不适合稀疏的数列或者矩阵，而且数组中元素的插入和删除操作也比较低效
- 链表：链表的随机访问的效率更低，但是它的优势是，不必事先规定数据的数量，表示稀疏的数列或矩阵时，可以更有效地利用存储空间，同时也利于数据的动态插入和删除。

树的特点：树的结点及其之间的边，和链表中的结点和链接在本质上是一样的，因此，我们可以模仿链表的结构，用编程语言中的指针或对象引用来构建树，除此之外，我们其实还可以用二维数组。用数组的行或列元素表示树中的结点，而行和列共同确定了两个树结点之间是不是存在边。可是在树中，这种二维关系通常是非常稀疏的、非常动态的，所以用数组效率就比较低下。

基于上面这些考虑，我们可以设计一个 TreeNode 类，表示有向树的结点和边。这个类需要体现前缀树结点最重要的两个属性。
- 这个结点所代表的字符，要用 label 变量表示。
- 这个结点有哪些子结点，要用 sons 哈希映射表示。之所以用哈希，是为了便于查找某个子结点（或者说对应的字符）是否存在。

### 如何使用递归和栈实现深度优先搜索？什么样的编程方式可以实现对树结点和边的操作？

仔细观察前缀树构建和查询，你会发现这两个不断重复迭代的过程，都可以使用递归编程来实现。换句话说，深度优先搜索的过程和递归调用在逻辑上是一致的。

在查询的过程中，至少有三种情况是无法在字典里找到被查的单词的。于是，我们需要在递归的代码中做相应的处理。

1. 被查单词所有字母都被处理完毕，但是我们仍然无法在字典里找到相应的词条。

    每次递归调用的函数开始，我们都需要判断待查询的单词，看看是否还有字母需要处理。如果没有更多的字母需要匹配了，那么再确认一下当前匹配到的结点本身是不是一个单词。如果是，就返回相应的单词解释，否则就返回查找失败。对于结点是不是一个单词，你可以使用 Node 类中的 explanation 变量来进行标识和判断，如果不是一个存在的单词，这个变量应该是空串或者 Null 值。

2. 搜索到前缀树的叶子结点，但是被查单词仍有未处理的字母，就返回查找失败。

    我们可以通过结点对象的 sons 变量来判断这个结点是不是叶子结点。如果是叶子结点，这个变量应该是空的 HashMap，或者 Null 值。

3. 搜索到中途，还没到达叶子结点，被查单词也有尚未处理的字母，但是当前被处理的字母已经无法和结点上的 label 匹配，返回查找失败。是不是叶子仍然通过结点对象的 sons 变量来判断。

### 如果我想遍历整个字典中所有的单词，那该怎么办呢？

查找一个单词的过程，其实就是在有向树中，找一条从树的根到代表这个单词的结点之通路

尽管函数递归调用非常直观，可是也有它自身的弱点。函数的每次嵌套，都可能产生新的变量来保存中间结果，这可能会消耗大量的内存。所以这里我们可以用一个更节省内存的数据结构，栈（Stack）。

栈的特点是先进后出（First In Last Out），也就是，最先进入栈的元素最后才会得到处理

从上面的步骤来看，栈先进后出的特性，可以模拟函数的递归调用。实际上，计算机系统里的函数递归，在内部也是通过栈来实现的。如果我们不使用函数调用时自动生成的栈，而是手动使用栈的数据结构，就能始终保持数据的副本只有一个，大大节省内存的使用量。

当我们把某个结点的子结点压入栈的时候，由于栈“先进后出”的特性，会导致子结点的访问顺序，和递归遍历时子结点的访问顺序相反。如果你希望两者保持一致，可以用一个临时的栈 stackTemp 把子结点入栈的顺序颠倒过来。

[TreeNode 类的代码 例子](./index.html)

### 小结

其实深度优先搜索的核心思想，就是按照当前的通路，不断地向前进，当遇到走不通的时候就回退到上一个结点，通过另一个新的边进行尝试。如果这一个点所有的方向都走不通的时候，就继续回退。这样一次一次循环下去，直到到达目标结点。树中的每个结点，既可以表示某个子问题和它所对应的抽象状态，也可以表示某个数据结构中一部分具体的值。

我们需要做的是，观察问题是否可以使用递归的方式来逐步简化，或者是否需要像前缀树这样遍历，如果是，就可以尝试使用深度优先搜索来帮助我们思考并解决问题。