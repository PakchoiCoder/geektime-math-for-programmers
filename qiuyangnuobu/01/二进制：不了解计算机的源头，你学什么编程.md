### 进制

十进制计数是使用 10 作为基数，那么二进制就是使用 2 作为基数，类比过来，二进制的数位就是 2^n 的形式

十进制 2871

    2871 = 2 * 1000 + 8 * 100 + 7 * 10 + 1

         = 2 * 10^3 + 8 * 10^2 + 7 * 10^1 + 1 * 10^0
     
         = 2000 + 800 + 70 + 1

二进制 110101

    1*2^5 + 1*2^4 + 0*2^3 + 1*2^2 + 0*2^1 + 1*2^0
    
    = 32 + 16 + 0 + 4 + 0 + 1
    
    = 53

任何非0数字的 0次方 均为1

        // 简易版任意进制 转 十进制

        function transformationDecimal(num, M) {
            const numStr = num.toString()
            const n = numStr.length
            let decimal = 0
            for (let i = 0; i < n; i++) {
                decimal += numStr[i] * M ** (n - i - 1)
            }
            return decimal
        }

计算机使用二进制和现代计算机系统的硬件实现有关。组成计算机系统的逻辑电路通常只有两个状态，即开关的接通与断开。
断开的状态我们用“0”来表示，接通的状态用“1”来表示。由于每位数据只有断开与接通两种状态，所以即便系统受到一定程度的干扰时，它仍然能够可靠地分辨出数字是“0”还是“1”。因此，在具体的系统实现中，二进制的数据表达具有抗干扰能力强、可靠性高的优点。

二进制也非常适合逻辑运算。逻辑运算中的“真”和“假”，正好与二进制的“0”和“1”两个数字相对应。逻辑运算中的加法（“或”运算）、乘法（“与”运算）以及否定（“非”运算）都可以通过“0”和“1”的加法、乘法和减法来实现。

### 二进制的位操作/位运算

#### 左移 右移

常见的二进制位操作包括向左移位和向右移位的移位操作，以及“或”“与”“异或”的逻辑操作。

二进制左移一位，其实就是将数字翻倍;

二进制右移一位，就是将数字除以 2 并求整数商的操作;

左移位无需考虑高位补 1 还是补 0（符号位可能为 1 或 0），所以不需要区分逻辑左移和算术左移。

逻辑右移和算术右移。逻辑右移 1 位，左边补 0 即可。 >>>

算术右移时保持符号位不变，除符号位之外的右移一位并补符号位 1。补的 1 仍然在符号位之后。 >>

在 C 或 C++ 语言中，逻辑右移和算数右移共享同一个运算符 >> 取决于运算数的类型 unsigned 采用逻辑右移，signed 采用算数右移

#### 位的“或” “与” “异或”

二进制的“1”和“0”分别对应逻辑中的“真”和“假”，因此可以针对位进行逻辑操作。

逻辑“或”的意思是，参与操作的位中只要有一个位是 1，那么最终结果就是 1

“与”的意思是，参与操作的位中必须全都是 1，那么最终结果才是 1（真），否则就为 0（假）

逻辑“异或”和“或”有所不同，它具有排异性，也就是说如果参与操作的位相同，那么最终结果就为 0（假），否则为 1（真）

####小结

二进制贯穿在很多常用的概念和思想中，例如逻辑判断、二分法、二叉树等等。逻辑判断中的真假值就是用二进制的 1 和 0 来表示的；二分法和二叉树都是把要处理的问题一分为二，正好也可以通过二进制的 1 和 0 来表示。因此，理解了二进制，你就能更加容易地理解很多计算机的数据结构和算法，也为我们后面的学习打下基础。