## 树的深度优先搜索（上）：如何才能高效率地查字典？

### 前缀树（prefix tree）

前缀树（prefix tree），或者叫字典树（trie）： 从树顶层的根结点一直遍历到最下层的叶子结点，最终逐步构成单词前缀的过程

前缀树是一种有向树。那什么是有向树？顾名思义，有向树就是一种树，特殊的就是，它的边是有方向的。而树是没有简单回路的连通图。

如果一个图里所有的边都是有向边，那么这个图就是有向图。如果一个图里所有的边都是无向边，那么这个图就是无向图。既含有向边，又含无向边的图，称为混合图。

在有向图中 以当前节点为出发点的边的数量 叫做 出度 以当前节点为重点的边的数量 叫做 入度

结点和边的交替序列组成的就是通路。所以，通路上的任意两个结点其实就是互为连通的。

理解了图的基本概念，我们再来看树和有向树。树是一种特殊的图，它是没有简单回路的连通无向图。这里的简单回路，其实就是指，除了第一个结点和最后一个结点相同外，其余结点不重复出现的回路。

### 有向树

- 有且仅有一个结点的入度为 0，这个结点被称为根；
- 除根以外的所有结点，入度都为 1。从树根到任一结点有且仅有一条有向通路。

除了基本定义 有向树还有几个重要的概念，父结点、子结点、兄弟结点、先辈结点、后辈结点、叶子结点、结点的高度（或深度）、树的高度（或深度）

### 前缀树的构建和查询

我们把空字符串作为树的根。对于每个单词，其中每一个字符都代表了有向树的一个结点。而前一个字符就是后一个字符的父结点，后一个字符是前一个字符的子结点。这也意味着，每增加一个字符，其实就是在当前字符结点下面增加一个子结点，相应地，树的高度也增加了 1

存在的就走之前的节点 不存在的就新增节点 按照这个方法给 所有的牛津词典 单词 都放到 树内 ，就能构造一棵包含这个字典里所有单词的前缀树

### 查询前缀树

从前缀树的根开始，查找下一个结点，顺着这个通路走下去，一直走到到某个结点。如果这个结点及其前缀代表了一个存在的单词，而待查找的单词和这个结点及其前缀正好完全匹配，那就说明成功找到了一个单词。否则，就表示无法找到。

几种特殊情况：
- 如果还没到叶子结点的时候，待查的单词就结束了。这个时候要看最后匹配上的非叶子结点是否代表一个单词；如果不是，那说明被查单词并不在字典中。
- 如果搜索到前缀树的叶子结点，但是被查单词仍有未处理的字母。由于叶子结点没有子结点，这时候，被查单词不可能在字典中。
- 如果搜索到一半，还没到达叶子结点，被查单词也有尚未处理的字母，但是当前被处理的字母已经无法和结点上的字符匹配了。这时候，被查单词不可能在字典中。

前缀树的构建和查询这两者在本质上其实是一致的。构建的时候，我们需要根据当前的前缀进行查询，然后才能找到合适的位置插入新的结点。而且，这两者都存在一个不断重复迭代的查找过程，我们把这种方式称为深度优先搜索（Depth First Search）。

深度优先遍历 就像 小时候玩游戏 走迷宫的时候，沿着墙的一面一只走 走到头 退回去继续沿着墙走 总能给全部都走一遍的效果一样。 


树在计算机领域中运用非常广泛。比如，二叉树和满二叉树。

二叉树是每个结点最多有两个子树的树结构，它可用于二叉查找树和二叉堆。

二叉树甚至可以用于图示化我们之前聊过的二分迭代。满二叉树是一棵高度为 n（高度从 1 开始计），且有 2^n-1 个结点的二叉树。在高度为 k(0