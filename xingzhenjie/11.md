# 11 | 树的深度优先搜索（上）：如何才能高效率地查字典？

## 字典树

前缀树，又称字典树或者单词查找树。是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。

优点：利用字符串的公共前缀来减少巢村时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。

## 图论的基本概念

* **前缀树**是一种有向树，有向树就是一种树，它的边是有方向的。
* **树**是没有简单回路的连通图。
* 一个图里所有的边都是有向边，那么这个图就是**有向图**。
* 一个图里所有的边都是无向边，那么这个图就是**无向图**。
* 既含有有向边，又含有无向边的图，称为**混合图**。

#### 有向图中：
* 以结点v为出发点的边的数量，叫做v的**出度**。
* 以v为终点的边之数量，称为v的**入度**。
* 结点和边的交替序列组成的就是**通路**。
* 通路上的任意两个阶段其实就是互为连通的。
* 如果一条通路的起始点v1和终止点vn相同，这种特殊的通路叫做**回路**。
* 从起始点到终止点所经过的边之数量，就是**通路的长度**。

#### 树和有向树
**树**是一种特殊的图，它是没有简单回路的连通无向图。这里的简单回路，其实就是指，除了第一个结点和最后一个结点相同外，其余结点不重复出现的回路。

**有向树**是一种特殊的树，其中的边都是有向的，而且满足以下几个条件：

* 有且仅有一个结点的入度为0，这个结点被称为跟；
* 除跟以外的所有结点，入度都为1。从树根到任一结点有且仅有一条有向通路。

有向树的几个重要概念：父结点，子结点，兄弟结点，先辈结点，后辈结点，叶子结点，结点的高度（或深度），树的高度（或深度）。

【图见课程】

## 前缀树的构建和查询

### 1.构建前缀树

把空字符串作为树的根。对于每个单词，其中美俄一个字符都代表了有向树的一个结点。而前一个字符就是后一个字符的父结点，后一个字符是前一个字符的子结点。没增加一个字符，其实就是在当前字符结点下面增加一个子结点，相应地，树的高度也增加1。

### 2.查询前缀树

从前缀树的根开始，查找下一个结点，顺着这个通路组下去，一直走到某个结点。如果这个结点及其前缀代表了一个存在的单词，而待查找的单词和这个结点及其前缀正好完全匹配，那就说明成功找到了一个单词。

**特殊情况**

* 如果还没到叶子结点的时候，待查询的单词就结束了。这个时候要看最后匹配上的非叶子结点是否代表一个单词；如果不是，那说明被查单词不在字典中。
* 如果搜索到前缀树的叶子结点，但是被查单词仍有未处理的字母。由于叶子结点没有子结点，这个时候，被查单词不可能在字典中。
* 如果搜索到一半，还没到达叶子结点，被查单词也有尚未处理的字母，但是当前被处理的字母已经无法和结点上的字符匹配了。这时候，被查单词不可能在字典中。

#### 前缀树的构建和查询在本质上其实是一致的

**树的深度优先搜索**，其实就是从树中的某个结点出发，沿着和这个结点相连的边向前走，找到下一个结点，然后以这种方式不断地发现新的结点和边，一直搜索下去，直到访问了所有和出发点连通的点，或者满足某个条件后停止。

如果到了某个点，发现和这个点直接相连的所有点都已经被访问过了，那么就回退到在这个点的父结点，继续查看是否有新的点可以访问；如果没有就继续回退，一直到出发点。由于单颗树中所有的结点都是连通的，所以通过深度优先的策略可以遍历树中所有的结点，因此也被称为**深度优先遍历**。

******

