#### 12 | 树的深度优先搜索（下）：如何才能高效率地查字典？
#### 如何使用数据结构表达树？
首先，什么样的数据结构可以表示树？
再来看树的特点。树的结点及其之间的边，和链表中的结点和链接在本质上是一样的，因此，我们可以模仿链表的结构，用编程语言中的指针或对象引用来构建树

#### 如何使用递归和栈实现深度优先搜索？
什么样的编程方式可以实现对树结点和边的操作？

在查询的过程中，至少有三种情况是无法在字典里找到被查的单词的。于是，我们需要在递归的代码中做相应的处理。
* 第一种情况：被查单词所有字母都被处理完毕，但是我们仍然无法在字典里找到相应的词条。
* 第二种情况：搜索到前缀树的叶子结点，但是被查单词仍有未处理的字母，就返回查找失败
* 第三种情况：搜索到中途，还没到达叶子结点，被查单词也有尚未处理的字母，但是当前被处理的字母已经无法和结点上的 label 匹配，返回查找失败。是不是叶子仍然通过结点对象的 sons 变量来判断
仔细观察一下，你应该能发现，查找一个单词的过程，其实就是在有向树中，找一条从树的根到代表这个单词的结点之通路。那么如果要遍历所有的单词，就意味着我们要找出从根到所有代表单词的结点之通路。所以，在每个结点上，我们不再是和某个待查询单词中的字符进行比较，而是要遍历该结点所有的子结点，这样才能找到所有可能的通路。我们还可以用递归来实现这一过程
#### 递归的弱点
函数的每次嵌套，都可能产生新的变量来保存中间结果，这可能会消耗大量的内存。所以这里我们可以用一个更节省内存的数据结构，栈（Stack）
栈的特点：先进后出

为什么栈可以进行深度优先搜索呢

```asm
this.dfs = function(callback){
        var color = initializeColor(); // 将所有顶点初始化为白色
        for (var i=0; i<vertices.length; i++){
            if (color[vertices[i]] === 'white'){ // 对每一个没有被访问过的顶点调用dfsVisit方法
                dfsVisit(vertices[i], color, callback); // {1}
            }
        }
        function dfsVisit(u, color, callback){
            color[u] = 'grey'; // 将顶点u置为灰，表明访问过但还没有完全探索
            callback &&　callback(u);　// 执行回调函数
            var neighbors = adjList.get(u); // 获取顶点u的所有相邻顶点
            for (var i=0; i<neighbors.length; i++){ // 探索所有相邻顶点
                var w = neighbors[i];
                if (color[w] === 'white'){ // 如果相邻的顶点没有被访问过，则对其执行dfsVisit方法
                    dfsVisit(w, color, callback);
                }
            }
            color[u] = 'black'; // 将顶点u置为黑，表明已经完全访问。
        };
    };
```
