#### 05 | 递归（上）：泛化数学归纳，如何将复杂问题简单化？

#### 问题：既然递归的函数值返回过程和基于循环的迭代法一致，我们直接用迭代法不就好了，为什么还要用递归的数学思想和编程方法呢？这是因为，在某些场景下，递归的解法比基于循环的迭代法更容易实现

在递归中，每次嵌套调用都会让函数体生成自己的局部变量，正好可以用来保存不同状态下的数值，为我们省去了大量中间变量的操作，极大地方便了设计和编程

#### 如何把复杂的问题简单化？
首先，我们来看，如何将数学归纳法的思想泛化成更一般的情况？数学归纳法考虑了两种情况：

* 假设 n=k-1 的时候，问题已经解决（或者已经找到解）。那么只要求解 n=k 的时候，问题如何解决（或者解是多少）；
* 初始状态，就是 n=1 的时候，问题如何解决（或者解是多少）

```asm
function test(totalReward: number, result: Array<number>) {
    let rewards: Array<number> = [1, 2, 5, 10];
    if (totalReward == 0) {
        console.log(result);
        return result;
    } else if (totalReward < 0) {
        return;
    } else {
        for (let i = 0; i < rewards.length; i++) {
            let newResult = [];
            newResult.push(rewards[i]);
            test(totalReward - rewards[i], newResult);
        }
    }
}

let total = 10;
test(total, []);

```

#### 小结：递归和循环其实都是迭代法的实现，而且在某些场合下，它们的实现是可以相互转化的。但是，对于某些应用场景，递归确很难被循环取代
* 1. 一个当前所采取的步骤。这种步骤可能是进行一次运算（例如每个棋格里的麦粒数是前一格的两倍），或者做一个选择（例如选择不同面额的纸币），或者是不同类型操作的结合（例如今天讲的赏金的案例）等等
* 2. 另一个更简单的问题。经过上述步骤之后，问题就会变得更加简单一点。这里“简单一点”，指运算的结果离目标值更近（例如赏金的总额），或者是完成了更多的选择（例如纸币的选择）。而“更简单的问题”，又可以通过嵌套调用，进一步简化和求解，直至达到结束条件。我们只需要保证递归编程能够体现这种将复杂问题逐步简化的思想，那么它就能帮助我们解决很多类似的问题。第二，递归会使用计算机的函数嵌套调用。而函数的调用本身，就可以保存很多中间状态和变量值，因此极大的方便了编程的处理。

