#### 09 | 动态规划（上）：如何实现基于编辑距离的查询推荐？

#### 什么是动态规划
那什么是动态规划呢？在递归那一节，我说过，我们可以通过不断分解问题，将复杂的任务简化为最基本的小问题，比如基于递归实现的归并排序、排列和组合等。不过有时候，我们并不用处理所有可能的情况，只要找到满足条件的最优解就行了。在这种情况下，我们需要在各种可能的局部解中，找出那些可能达到最优的局部解，而放弃其他的局部解。这个寻找最优解的过程其实就是动态规划
动态规划需要通过子问题的最优解，推导出最终问题的最优解，因此这种方法特别注重子问题之间的转移关系。我们通常把这些子问题之间的转移称为状态转移，并把用于刻画这些状态转移的表达式称为状态转移方程。很显然，找到合适的状态转移方程，是动态规划的关键

#### 编辑距离
* 由一个字符串转成另一个字符串所需的最少编辑操作次数，我们就叫作编辑距离
这个概念是俄罗斯科学家莱文斯坦提出来的，所以我们也把编辑距离称作莱文斯坦距离（Levenshtein distance）。很显然，编辑距离越小，说明这两个字符串越相似，可以互相作为查询推荐。编辑操作有这三种：把一个字符替换成另一个字符；插入一个字符；删除一个字符。
比如，我们想把 mouuse 转换成 mouse，有很多方法可以实现，但是很显然，直接删除一个“u”是最简单的，所以这两者的编辑距离就是 1

#### 状态转移

用js实现编辑距离算法（Edit Distance）
#### 给出两个单词word1和word2，计算出将word1 转换为word2的最少操作次数

你总共三种操作方法：
* 插入一个字符
* 删除一个字符
* 替换一个字符

解析
* 编辑无非就是三种情况，字符的插入、删除以及编辑：
* 插入一个字符为进行了一次操作，如：fat->fait;
* 删除一个字符也视为进行一次操作，如：haven->have;
* 替换字符也视为进行一次操作，如：let->lit。

````asm
在相同位置上两个字符串不同:cost=1；反则为0
matrix[m][n]=Math.min(matrix[m-1][n]+1,matrix[m][n-1]+1,matrix[m-1][n-1]+cost)
````
````asm
export const mindis = (s1: string, s2: string) => {
    const len1 = s1.length;
    const len2 = s2.length;
    let matrix = []; // 数组
    for (let i = 0; i <= len1; i++) {
        //构造二维数组
        matrix[i] = [];
        for (let j = 0; j <= len2; j++) {
            //初始化
            if (i === 0) {
                matrix[i][j] = j;
            } else if (j === 0) {
                matrix[i][j] = i;
            } else {
                // 进行最小值分析
                let cost = 0;
                if (s1[i - 1] != s2[j - 1]) {// 相同为0，不同置1
                    cost = 1
                }
                const temp = matrix[i - 1][j - 1] + cost
                matrix[i][j] = Math.min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1, temp)
            }

        }
    }
    return matrix[len1][len2]
}

console.log(mindis("word1","word2")) // 1

````

